package com.gymflow.util;

import com.gymflow.model.AttendanceRecord;
import com.gymflow.model.WorkoutPlan;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;

/**
 * Utility class for CSV import/export operations.
 * Handles workout plan templates and attendance reports.
 */
public final class CsvUtil {
    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final int MAX_FILE_SIZE_MB = 10;
    private static final long MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;

    private CsvUtil() {
        // Utility class - prevent instantiation
    }

    /**
     * Exports a list of workout plans to a CSV file.
     *
     * @param workoutPlans the list of workout plans to export
     * @param targetPath the path where the CSV file will be created
     * @throws IOException if an I/O error occurs
     * @throws IllegalArgumentException if the path is invalid
     */
    public static void exportWorkoutTemplates(List<WorkoutPlan> workoutPlans, Path targetPath) throws IOException {
        if (targetPath == null) {
            throw new IllegalArgumentException("Target path cannot be null");
        }

        // Ensure parent directory exists
        Path parentDir = targetPath.getParent();
        if (parentDir != null && !Files.exists(parentDir)) {
            Files.createDirectories(parentDir);
        }

        try (BufferedWriter writer = Files.newBufferedWriter(targetPath)) {
            // Write CSV header with all fields
            writer.write("Title,Description,Difficulty,Member ID,Trainer ID,Muscle Group,Workout Type,Duration Minutes,Equipment Needed,Target Sets,Target Reps,Rest Seconds,Created At");
            writer.newLine();

            // Write data rows
            for (WorkoutPlan plan : workoutPlans) {
                writer.write(escapeCsvField(plan.getTitle()));
                writer.write(",");
                writer.write(escapeCsvField(plan.getDescription()));
                writer.write(",");
                writer.write(escapeCsvField(plan.getDifficulty()));
                writer.write(",");
                writer.write(String.valueOf(plan.getMemberId()));
                writer.write(",");
                writer.write(String.valueOf(plan.getTrainerId()));
                writer.write(",");
                writer.write(escapeCsvField(plan.getMuscleGroup()));
                writer.write(",");
                writer.write(escapeCsvField(plan.getWorkoutType()));
                writer.write(",");
                writer.write(plan.getDurationMinutes() != null ? String.valueOf(plan.getDurationMinutes()) : "");
                writer.write(",");
                writer.write(escapeCsvField(plan.getEquipmentNeeded()));
                writer.write(",");
                writer.write(plan.getTargetSets() != null ? String.valueOf(plan.getTargetSets()) : "");
                writer.write(",");
                writer.write(plan.getTargetReps() != null ? String.valueOf(plan.getTargetReps()) : "");
                writer.write(",");
                writer.write(plan.getRestSeconds() != null ? String.valueOf(plan.getRestSeconds()) : "");
                writer.write(",");
                if (plan.getCreatedAt() != null) {
                    writer.write(plan.getCreatedAt().format(DATE_TIME_FORMATTER));
                }
                writer.newLine();
            }
        }
    }

    /**
     * Imports workout plans from a CSV file.
     *
     * @param sourcePath the path to the CSV file to import
     * @return list of imported workout plans (without IDs, as they will be generated by database)
     * @throws IOException if an I/O error occurs
     * @throws IllegalArgumentException if the file format is invalid
     */
    public static List<WorkoutPlan> importWorkoutTemplates(Path sourcePath) throws IOException {
        validateFile(sourcePath);

        List<WorkoutPlan> workoutPlans = new ArrayList<>();

        try (BufferedReader reader = Files.newBufferedReader(sourcePath)) {
            String headerLine = reader.readLine();
            if (headerLine == null) {
                throw new IllegalArgumentException("CSV file is empty");
            }

            // Validate header - support both old and new formats for backward compatibility
            String expectedOldHeader = "Title,Description,Difficulty,Member ID,Trainer ID,Created At";
            String expectedNewHeader = "Title,Description,Difficulty,Member ID,Trainer ID,Muscle Group,Workout Type,Duration Minutes,Equipment Needed,Target Sets,Target Reps,Rest Seconds,Created At";
            String trimmedHeader = headerLine.trim();
            boolean isOldFormat = trimmedHeader.equalsIgnoreCase(expectedOldHeader);
            boolean isNewFormat = trimmedHeader.equalsIgnoreCase(expectedNewHeader);
            
            if (!isOldFormat && !isNewFormat) {
                throw new IllegalArgumentException("Invalid CSV header. Expected format with fields: Title,Description,Difficulty,Member ID,Trainer ID,Muscle Group,Workout Type,Duration Minutes,Equipment Needed,Target Sets,Target Reps,Rest Seconds,Created At");
            }

            String line;
            int lineNumber = 1; // Header is line 1, first data row is line 2

            while ((line = reader.readLine()) != null) {
                lineNumber++;
                line = line.trim();

                // Skip empty lines
                if (line.isEmpty()) {
                    continue;
                }

                try {
                    WorkoutPlan plan = parseWorkoutPlanLine(line, lineNumber, isNewFormat);
                    workoutPlans.add(plan);
                } catch (IllegalArgumentException e) {
                    System.err.println("Skipping line " + lineNumber + ": " + e.getMessage());
                    // Continue processing other lines
                }
            }
        }

        return workoutPlans;
    }

    /**
     * Exports attendance records to a CSV file.
     *
     * @param attendanceRecords the list of attendance records to export
     * @param targetPath the path where the CSV file will be created
     * @throws IOException if an I/O error occurs
     * @throws IllegalArgumentException if the path is invalid
     */
    public static void exportAttendanceReport(List<AttendanceRecord> attendanceRecords, Path targetPath) throws IOException {
        exportAttendanceReport(attendanceRecords, targetPath, null, null);
    }

    /**
     * Exports attendance records to a CSV file with member and class names.
     *
     * @param attendanceRecords the list of attendance records to export
     * @param targetPath the path where the CSV file will be created
     * @param memberNameMap optional map of member ID to member name (can be null)
     * @param classNameMap optional map of session ID to class name (can be null)
     * @throws IOException if an I/O error occurs
     * @throws IllegalArgumentException if the path is invalid
     */
    public static void exportAttendanceReport(List<AttendanceRecord> attendanceRecords, Path targetPath,
                                             java.util.Map<Long, String> memberNameMap,
                                             java.util.Map<Long, String> classNameMap) throws IOException {
        if (targetPath == null) {
            throw new IllegalArgumentException("Target path cannot be null");
        }

        // Ensure parent directory exists
        Path parentDir = targetPath.getParent();
        if (parentDir != null && !Files.exists(parentDir)) {
            Files.createDirectories(parentDir);
        }

        try (BufferedWriter writer = Files.newBufferedWriter(targetPath)) {
            // Write CSV header with names if maps are provided
            if (memberNameMap != null && classNameMap != null) {
                writer.write("Record ID,Session ID,Class Name,Member ID,Member Name,Attended");
            } else {
                writer.write("Record ID,Session ID,Member ID,Attended");
            }
            writer.newLine();

            // Write data rows
            for (AttendanceRecord record : attendanceRecords) {
                writer.write(String.valueOf(record.getId()));
                writer.write(",");
                writer.write(String.valueOf(record.getSessionId()));
                
                if (memberNameMap != null && classNameMap != null) {
                    // Include class name
                    String className = classNameMap.getOrDefault(record.getSessionId(), "Unknown Class");
                    writer.write(",");
                    writer.write(escapeCsvField(className));
                }
                
                writer.write(",");
                writer.write(String.valueOf(record.getMemberId()));
                
                if (memberNameMap != null && classNameMap != null) {
                    // Include member name
                    String memberName = memberNameMap.getOrDefault(record.getMemberId(), "Unknown Member");
                    writer.write(",");
                    writer.write(escapeCsvField(memberName));
                }
                
                writer.write(",");
                writer.write(record.isAttended() ? "Yes" : "No");
                writer.newLine();
            }
        }
    }

    /**
     * Validates a file before import.
     *
     * @param filePath the path to validate
     * @throws FileNotFoundException if the file doesn't exist
     * @throws IllegalArgumentException if the file is too large or invalid format
     */
    public static void validateFile(Path filePath) throws FileNotFoundException {
        if (filePath == null) {
            throw new IllegalArgumentException("File path cannot be null");
        }

        if (!Files.exists(filePath)) {
            throw new FileNotFoundException("File not found: " + filePath);
        }

        if (!Files.isRegularFile(filePath)) {
            throw new IllegalArgumentException("Path is not a regular file: " + filePath);
        }

        try {
            long fileSize = Files.size(filePath);
            if (fileSize > MAX_FILE_SIZE_BYTES) {
                throw new IllegalArgumentException(
                    String.format("File size (%d MB) exceeds maximum allowed size (%d MB)",
                        fileSize / (1024 * 1024), MAX_FILE_SIZE_MB)
                );
            }

            if (fileSize == 0) {
                throw new IllegalArgumentException("File is empty");
            }
        } catch (IOException e) {
            throw new IllegalArgumentException("Cannot read file: " + e.getMessage(), e);
        }

        // Check file extension
        String fileName = filePath.getFileName().toString().toLowerCase();
        if (!fileName.endsWith(".csv")) {
            throw new IllegalArgumentException("File must have .csv extension");
        }
    }

    /**
     * Escapes a field value for CSV format.
     * Handles commas, quotes, and newlines in field values.
     *
     * @param field the field value to escape
     * @return the escaped field value
     */
    private static String escapeCsvField(String field) {
        if (field == null) {
            return "";
        }

        // If field contains comma, quote, or newline, wrap in quotes and escape quotes
        if (field.contains(",") || field.contains("\"") || field.contains("\n")) {
            return "\"" + field.replace("\"", "\"\"") + "\"";
        }

        return field;
    }

    /**
     * Parses a single line from a workout plan CSV file.
     *
     * @param line the CSV line to parse
     * @param lineNumber the line number (for error messages)
     * @param isNewFormat whether the CSV uses the new format with all fields
     * @return a WorkoutPlan object (with id=0, as it will be generated by database)
     * @throws IllegalArgumentException if the line format is invalid
     */
    private static WorkoutPlan parseWorkoutPlanLine(String line, int lineNumber, boolean isNewFormat) {
        String[] fields = parseCsvLine(line);

        int minFields = isNewFormat ? 13 : 5;
        if (fields.length < minFields) {
            throw new IllegalArgumentException("Line has insufficient fields. Expected at least " + minFields + ", got " + fields.length);
        }

        try {
            String title = unescapeCsvField(fields[0]);
            String description = unescapeCsvField(fields.length > 1 ? fields[1] : "");
            String difficulty = unescapeCsvField(fields.length > 2 ? fields[2] : "Beginner");
            long memberId = Long.parseLong(fields.length > 3 ? fields[3].trim() : "0");
            long trainerId = Long.parseLong(fields.length > 4 ? fields[4].trim() : "0");
            
            // New fields (only in new format)
            String muscleGroup = null;
            String workoutType = null;
            Integer durationMinutes = null;
            String equipmentNeeded = null;
            Integer targetSets = null;
            Integer targetReps = null;
            Integer restSeconds = null;
            
            if (isNewFormat && fields.length >= 13) {
                muscleGroup = unescapeCsvField(fields[5]);
                workoutType = unescapeCsvField(fields[6]);
                durationMinutes = parseInteger(fields[7]);
                equipmentNeeded = unescapeCsvField(fields[8]);
                targetSets = parseInteger(fields[9]);
                targetReps = parseInteger(fields[10]);
                restSeconds = parseInteger(fields[11]);
            }
            
            LocalDateTime createdAt = null;
            int dateFieldIndex = isNewFormat ? 12 : 5;

            // Parse created date if present
            if (fields.length > dateFieldIndex && fields[dateFieldIndex] != null && !fields[dateFieldIndex].trim().isEmpty()) {
                try {
                    createdAt = LocalDateTime.parse(fields[dateFieldIndex].trim(), DATE_TIME_FORMATTER);
                } catch (DateTimeParseException e) {
                    System.err.println("Warning: Could not parse date on line " + lineNumber + ", using current time");
                    createdAt = LocalDateTime.now();
                }
            } else {
                createdAt = LocalDateTime.now();
            }

            // Validate required fields
            if (title == null || title.trim().isEmpty()) {
                throw new IllegalArgumentException("Title is required");
            }

            if (memberId <= 0) {
                throw new IllegalArgumentException("Member ID must be greater than 0");
            }

            if (trainerId <= 0) {
                throw new IllegalArgumentException("Trainer ID must be greater than 0");
            }

            // Create WorkoutPlan with all fields
            return new WorkoutPlan(0, memberId, trainerId, title.trim(), 
                                 description != null ? description.trim() : null,
                                 difficulty != null ? difficulty.trim() : "Beginner",
                                 muscleGroup != null && !muscleGroup.isEmpty() ? muscleGroup.trim() : null,
                                 workoutType != null && !workoutType.isEmpty() ? workoutType.trim() : null,
                                 durationMinutes,
                                 equipmentNeeded != null && !equipmentNeeded.isEmpty() ? equipmentNeeded.trim() : null,
                                 targetSets,
                                 targetReps,
                                 restSeconds,
                                 createdAt);

        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid number format: " + e.getMessage());
        }
    }
    
    /**
     * Parses an integer from a string, returning null if empty or invalid.
     */
    private static Integer parseInteger(String value) {
        if (value == null || value.trim().isEmpty()) {
            return null;
        }
        try {
            return Integer.parseInt(value.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * Parses a CSV line, handling quoted fields.
     *
     * @param line the CSV line to parse
     * @return array of field values
     */
    private static String[] parseCsvLine(String line) {
        List<String> fields = new ArrayList<>();
        StringBuilder currentField = new StringBuilder();
        boolean inQuotes = false;

        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);

            if (c == '"') {
                if (inQuotes && i + 1 < line.length() && line.charAt(i + 1) == '"') {
                    // Escaped quote
                    currentField.append('"');
                    i++; // Skip next quote
                } else {
                    // Toggle quote state
                    inQuotes = !inQuotes;
                }
            } else if (c == ',' && !inQuotes) {
                // End of field
                fields.add(currentField.toString());
                currentField = new StringBuilder();
            } else {
                currentField.append(c);
            }
        }

        // Add last field
        fields.add(currentField.toString());

        return fields.toArray(new String[0]);
    }

    /**
     * Unescapes a CSV field value.
     *
     * @param field the field value to unescape
     * @return the unescaped field value
     */
    private static String unescapeCsvField(String field) {
        if (field == null || field.trim().isEmpty()) {
            return null;
        }

        field = field.trim();

        // Remove surrounding quotes if present
        if (field.startsWith("\"") && field.endsWith("\"")) {
            field = field.substring(1, field.length() - 1);
            // Unescape double quotes
            field = field.replace("\"\"", "\"");
        }

        return field.isEmpty() ? null : field;
    }
}
